(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/regenerator'), require('extendable-media-recorder-wav-encoder-broker'), require('worker-factory'), require('@babel/runtime/helpers/slicedToArray')) :
    typeof define === 'function' && define.amd ? define(['@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/regenerator', 'extendable-media-recorder-wav-encoder-broker', 'worker-factory', '@babel/runtime/helpers/slicedToArray'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global._asyncToGenerator, global._regeneratorRuntime, global.extendableMediaRecorderWavEncoderBroker, global.workerFactory, global._slicedToArray));
})(this, (function (_asyncToGenerator, _regeneratorRuntime, extendableMediaRecorderWavEncoderBroker, workerFactory, _slicedToArray) { 'use strict';

    var createDeregisterEncoder = function createDeregisterEncoder(encoderBrokerRegistry, encoderIds) {
      return function (encoderId) {
        var regexAsString = encoderIds.get(encoderId);
        if (regexAsString === undefined) {
          throw new Error('There was no encoder stored with the given id.');
        }
        encoderBrokerRegistry["delete"](regexAsString);
        encoderIds["delete"](encoderId);
      };
    };

    var createFinishEncoding = function createFinishEncoding(closePort, removeEncoderInstance) {
      return function (encoderInstanceId) {
        var _removeEncoderInstanc = removeEncoderInstance(encoderInstanceId),
          _removeEncoderInstanc2 = _slicedToArray(_removeEncoderInstanc, 4),
          encoderBroker = _removeEncoderInstanc2[0],
          port = _removeEncoderInstanc2[1],
          isRecording = _removeEncoderInstanc2[2],
          sampleRate = _removeEncoderInstanc2[3];
        if (!isRecording) {
          return encoderBroker.encode(encoderInstanceId, null);
        }
        return new Promise(function (resolve) {
          port.onmessage = function (_ref) {
            var data = _ref.data;
            if (data.length === 0) {
              closePort(port);
              resolve(encoderBroker.encode(encoderInstanceId, null));
            } else {
              encoderBroker.record(encoderInstanceId, sampleRate, data);
            }
          };
        });
      };
    };

    var createGetEncoderInstance = function createGetEncoderInstance(encoderInstancesRegistry) {
      return function (encoderInstanceId) {
        var entry = encoderInstancesRegistry.get(encoderInstanceId);
        if (entry === undefined) {
          throw new Error('There was no instance of an encoder stored with the given id.');
        }
        return entry;
      };
    };

    var createInstantiateEncoder = function createInstantiateEncoder(closePort, encoderInstancesRegistry, pickCapableEncoderBroker) {
      return function (encoderInstanceId, mimeType, sampleRate) {
        if (encoderInstancesRegistry.has(encoderInstanceId)) {
          throw new Error("There is already an encoder instance registered with an id called \"".concat(encoderInstanceId, "\"."));
        }
        var encoderBroker = pickCapableEncoderBroker(mimeType);
        var _MessageChannel = new MessageChannel(),
          port1 = _MessageChannel.port1,
          port2 = _MessageChannel.port2;
        var entry = [encoderBroker, port1, true, sampleRate];
        encoderInstancesRegistry.set(encoderInstanceId, entry);
        port1.onmessage = function (_ref) {
          var data = _ref.data;
          if (data.length === 0) {
            closePort(port1);
            entry[2] = false;
          } else {
            encoderBroker.record(encoderInstanceId, sampleRate, data.map(function (channelDataOrNumberOfSamples) {
              return typeof channelDataOrNumberOfSamples === 'number' ? new Float32Array(channelDataOrNumberOfSamples) : channelDataOrNumberOfSamples;
            }));
          }
        };
        return port2;
      };
    };

    var createPickCapableEncoderBroker = function createPickCapableEncoderBroker(encoderBrokerRegistry) {
      return function (mimeType) {
        for (var _i = 0, _Array$from = Array.from(encoderBrokerRegistry.values()); _i < _Array$from.length; _i++) {
          var _Array$from$_i = _slicedToArray(_Array$from[_i], 2),
            regex = _Array$from$_i[0],
            encoderBroker = _Array$from$_i[1];
          if (regex.test(mimeType)) {
            return encoderBroker;
          }
        }
        throw new Error('There is no encoder registered which could handle the given mimeType.');
      };
    };

    var createRegisterEncoder = function createRegisterEncoder(encoderBrokerRegistry, encoderIds, wrap) {
      return /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(encoderId, port) {
          var encoderBroker, regex, regexAsString;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                encoderBroker = wrap(port);
                _context.next = 3;
                return encoderBroker.characterize();
              case 3:
                regex = _context.sent;
                regexAsString = regex.toString();
                if (!encoderBrokerRegistry.has(regexAsString)) {
                  _context.next = 7;
                  break;
                }
                throw new Error('There is already an encoder stored which handles exactly the same mime types.');
              case 7:
                if (!encoderIds.has(encoderId)) {
                  _context.next = 9;
                  break;
                }
                throw new Error("There is already an encoder registered with an id called \"".concat(encoderId, "\"."));
              case 9:
                encoderBrokerRegistry.set(regexAsString, [regex, encoderBroker]);
                encoderIds.set(encoderId, regexAsString);
                return _context.abrupt("return", regex);
              case 12:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }();
    };

    var createRemoveEncoderInstance = function createRemoveEncoderInstance(encoderInstancesRegistry, getEncoderInstance) {
      return function (encoderInstanceId) {
        var entry = getEncoderInstance(encoderInstanceId);
        encoderInstancesRegistry["delete"](encoderInstanceId);
        return entry;
      };
    };

    var createRequestPartialEncoding = function createRequestPartialEncoding(getEncoderInstance) {
      return function (encoderInstanceId, timeslice) {
        var _getEncoderInstance = getEncoderInstance(encoderInstanceId),
          _getEncoderInstance2 = _slicedToArray(_getEncoderInstance, 1),
          encoderBroker = _getEncoderInstance2[0];
        return encoderBroker.encode(encoderInstanceId, timeslice);
      };
    };

    var closePort = function closePort(port) {
      port.onmessage = null;
      port.close();
    };

    var encoderBrokerRegistry = new Map();
    var encoderIds = new Map();
    var deregisterEncoder = createDeregisterEncoder(encoderBrokerRegistry, encoderIds);
    var encoderInstancesRegistry = new Map();
    var getEncoderInstance = createGetEncoderInstance(encoderInstancesRegistry);
    var removeEncoderInstance = createRemoveEncoderInstance(encoderInstancesRegistry, getEncoderInstance);
    var finishEncoding = createFinishEncoding(closePort, removeEncoderInstance);
    var pickCapableEncoderBroker = createPickCapableEncoderBroker(encoderBrokerRegistry);
    var instantiateEncoder = createInstantiateEncoder(closePort, encoderInstancesRegistry, pickCapableEncoderBroker);
    var registerEncoder = createRegisterEncoder(encoderBrokerRegistry, encoderIds, extendableMediaRecorderWavEncoderBroker.wrap);
    var requestPartialEncoding = createRequestPartialEncoding(getEncoderInstance);
    workerFactory.createWorker(self, {
      deregister: function () {
        var _deregister = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
          var encoderId;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                encoderId = _ref.encoderId;
                deregisterEncoder(encoderId);
                return _context.abrupt("return", {
                  result: null
                });
              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function deregister(_x) {
          return _deregister.apply(this, arguments);
        }
        return deregister;
      }(),
      encode: function () {
        var _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {
          var encoderInstanceId, timeslice, arrayBuffers;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                encoderInstanceId = _ref2.encoderInstanceId, timeslice = _ref2.timeslice;
                if (!(timeslice === null)) {
                  _context2.next = 7;
                  break;
                }
                _context2.next = 4;
                return finishEncoding(encoderInstanceId);
              case 4:
                _context2.t0 = _context2.sent;
                _context2.next = 10;
                break;
              case 7:
                _context2.next = 9;
                return requestPartialEncoding(encoderInstanceId, timeslice);
              case 9:
                _context2.t0 = _context2.sent;
              case 10:
                arrayBuffers = _context2.t0;
                return _context2.abrupt("return", {
                  result: arrayBuffers,
                  transferables: arrayBuffers
                });
              case 12:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function encode(_x2) {
          return _encode.apply(this, arguments);
        }
        return encode;
      }(),
      instantiate: function instantiate(_ref3) {
        var encoderInstanceId = _ref3.encoderInstanceId,
          mimeType = _ref3.mimeType,
          sampleRate = _ref3.sampleRate;
        var port = instantiateEncoder(encoderInstanceId, mimeType, sampleRate);
        return {
          result: port,
          transferables: [port]
        };
      },
      register: function () {
        var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4) {
          var encoderId, port;
          return _regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                encoderId = _ref4.encoderId, port = _ref4.port;
                _context3.next = 3;
                return registerEncoder(encoderId, port);
              case 3:
                _context3.t0 = _context3.sent;
                return _context3.abrupt("return", {
                  result: _context3.t0
                });
              case 5:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        function register(_x3) {
          return _register.apply(this, arguments);
        }
        return register;
      }()
    });

}));
